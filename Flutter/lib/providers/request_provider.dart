import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:skripsi/models/leave_request_model.dart';

class LeaveRequestProvider with ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  String get _currentUserId => _auth.currentUser?.uid ?? '';

  Future<void> addLeaveRequest(LeaveRequest request) async {
    try {
      if (_currentUserId.isEmpty) {
        throw Exception('User not logged in');
      }

      await _firestore.collection('users').doc(_currentUserId).collection('leave_requests').add({
        'leaveType': request.leaveType,
        'startDate': request.startDate.toUtc(),
        'endDate': request.endDate.toUtc(),
        'reason': request.reason,
        'status': request.status,
      });

      notifyListeners();
    } catch (e) {
      throw Exception('Failed to submit leave request: $e');
    }
  }

  Stream<List<LeaveRequest>> fetchLeaveRequests() {
    if (_currentUserId.isEmpty) {
      return Stream.error('User not logged in');
    }

    return _firestore
        .collection('users')
        .doc(_currentUserId)
        .collection('leave_requests')
        .orderBy('endDate', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data();
        return LeaveRequest(
          id: doc.id,
          leaveType: data['leaveType'],
          startDate: (data['startDate'] as Timestamp).toDate(),
          endDate: (data['endDate'] as Timestamp).toDate(),
          reason: data['reason'],
          status: data['status'] ?? "Pending",
        );
      }).toList();
    });
  }

  Future<void> processPendingLeaveRequests() async {
    if (_currentUserId.isEmpty) return;

    final snapshot = await _firestore.collection('users').doc(_currentUserId).collection('leave_requests').get();

    for (final doc in snapshot.docs) {
      final data = doc.data();
      final leaveType = data['leaveType'];
      final status = (data['status'] ?? 'Pending').toLowerCase();
      final attendanceGenerated = data['attendanceGenerated'] ?? false;

      if (leaveType == "Attendance Request") {
        final startDate = (data['startDate'] as Timestamp).toDate();
        final endDate = (data['endDate'] as Timestamp).toDate();

        if (status == "approved" && !attendanceGenerated) {
          await _addAutoAttendance(startDate, endDate, requestId: doc.id);
        } else if (status == "rejected" && attendanceGenerated) {
          await _removeAutoAttendanceByRequestId(doc.id);
          await _firestore
              .collection('users')
              .doc(_currentUserId)
              .collection('leave_requests')
              .doc(doc.id)
              .update({'attendanceGenerated': false});
        }
      }
    }
  }

  Future<void> removeLeaveRequest(String requestId) async {
    try {
      if (_currentUserId.isEmpty) {
        throw Exception('User not logged in');
      }

      await _firestore.collection('users').doc(_currentUserId).collection('leave_requests').doc(requestId).delete();

      notifyListeners();
    } catch (e) {
      throw Exception('Failed to cancel leave request: $e');
    }
  }

  Future<void> _addAutoAttendance(DateTime start, DateTime end, {String? requestId}) async {
    final user = _auth.currentUser;
    if (user == null) return;

    final userId = user.uid;
    final userEmail = user.email;
    final attendanceCollection = _firestore.collection('users').doc(userId).collection('attendance');

    final existing = await attendanceCollection.where('requestId', isEqualTo: requestId).get();

    if (existing.docs.isNotEmpty) {
      return;
    }

    DateTime current = start;
    while (!current.isAfter(end)) {
      final clockIn = DateTime(current.year, current.month, current.day, 9);
      final clockOut = DateTime(current.year, current.month, current.day, 17);

      await attendanceCollection.add({
        'activityType': 'Clock In',
        'uploadedAt': clockIn.toUtc(),
        'url': '',
        'userEmail': userEmail,
        'autoGenerated': true,
        'requestId': requestId,
      });

      await attendanceCollection.add({
        'activityType': 'Clock Out',
        'uploadedAt': clockOut.toUtc(),
        'url': '',
        'userEmail': userEmail,
        'autoGenerated': true,
        'requestId': requestId,
      });

      current = current.add(const Duration(days: 1));
    }

    await _firestore.runTransaction((transaction) async {
      final leaveRef = _firestore.collection('users').doc(userId).collection('leave_requests').doc(requestId);

      transaction.update(leaveRef, {'attendanceGenerated': true});
    });
  }

  Future<void> _removeAutoAttendanceByRequestId(String requestId) async {
    final user = _auth.currentUser;
    if (user == null) return;

    final attendanceDocs = await _firestore
        .collection('users')
        .doc(user.uid)
        .collection('attendance')
        .where('requestId', isEqualTo: requestId)
        .get();

    for (final doc in attendanceDocs.docs) {
      await doc.reference.delete();
    }
  }
}
